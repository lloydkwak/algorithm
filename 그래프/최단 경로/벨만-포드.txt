
단일 시작점 최단 경로 알고리즘
---> 음수 간선을 포함한 그래프에서도 적용 가능

동작 방식
1. 시작 정점에서 각 정점까지 최단 경로 상한 예측
2. 오차를 반복적으로 줄여 나가는 방식 적용
---> upper[] : 각 정점까지 최단 거리의 상한 유지

----------------------------------------------------------------------------------------------

1. 시작 정점 s에 대해 upper[s] = 0, 나머지는 INF로 초기화
2. 시작 정점에서 u, v 까지 최단 거리 dist[u], dist[v];
---> dist[v] <= dist[u] + w(u, v)
3. 2번의 특성을 이용하여 dist[v] > dist[u] + w(u, v) 일때 dist[v] = dist[u] + w(u, v)로 줄인다.
= 완화(relax)

----------------------------------------------------------------------------------------------
정당성 증명 : 시작점 0에서 한점 씩 따라가면 항상 성립함을 보일 수 있다.
----------------------------------------------------------------------------------------------

//정점 개수
int V;
//그래프의 인접 리스트 표현
vector<pair<int, int>> adj[MAX_V];

vector<int> bellmanFord(int src){
    vector<int> upper(V, INF);
    upper[src] = 0;
    bool update;
    //정점의 개수 만큼 순회
    for(int iter = 0; iter < V; ++iter){
        update = false;
        for(int here = 0; here < V; ++here){
            for(int i = 0; i < adj[here].size(); ++i){
                int there = adj[here][i].first;
                int cost = adj[here][i].second;
                if(upper[there] > upper[here] + cost){
                    upper[there] = upper[here] + cost;
                    update = true;
                }
            }
        }
        //모든 간선에 대해 완화(relax) 실패시 즉시 종료
        if(!update) break;
    }
    //음수 사이클이 존재하는 경우 빈 배열 반환
    if(update) upper.clear();
    return upper;
}

---> 첫번째 for문은 V 번, 그 안에 두개는 E번 실행
---> O(|V||E|)

----------------------------------------------------------------------------------------------

실제 경로
: 각 정점을 마지막으로 완화 시킨 간선들을 모으면 최단 경로를 얻을 수 있다.

경로 존재 여부
: 음수 사이클이 존재할 수 있기 때문에 upper[u] != INF로는 확인 불가.
---> 적당히 큰 M에 대해 upper[u] < INF - M;

----------------------------------------------------------------------------------------------