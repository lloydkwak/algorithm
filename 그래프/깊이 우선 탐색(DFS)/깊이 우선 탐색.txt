깊이 우선 탐색(depth-first search, DFS)
: 현재 인접한 간선 중 방문하지 않은 간선이 있다면 무조건 따라가는 방식
---> 더이상 갈 곳이 없으면 왔던 방향으로 돌아감(재귀를 이용하면 쉽게 표현 가능)

-------------------------------------------------------------------------------------------------------

//그래프의 인접 행렬 표현
vector<vector<int>> adj;
//정점 방문 여부
vector<bool> visited;

//깊이 우선 탐색 구현
void dfs(int here){
    cout << "DFS visited " << here << endl;
    visited[here] = true;
    //모든 인접한 정점 순회
    for(int i = 0; i < adj[here].size(); ++i){
        int there = adj[here][i];
        //방문하지 않았다면 방문
        if(!visited[there]) dfs(there);
    }
    //더이상 방문할 정점이 없으니. 재귀 호출 종료로 이전 정점으로 돌아감.
}

//모든 정점 방문
void dfsAll(){
    //visited false로 초기화
    visited = vector<bool>(adj.size(), false);
    //모든 정점을 순회, 방문하지 않은 정점 방문
    for(int i = 0; i < adj.size(); ++i){
        if(!visited[i]) dfs(i);
    }
}
//모든 정점이 연결되어 있다는 보장이 없기 때문에 dfsAll 함수가 필수적으로 필요하다.

-------------------------------------------------------------------------------------------------------

활용
1. 두 정점이 연결되어 있는지 확인 ---> dfs() 수행후 visited[] 참조
2. 연결된 부분집합의 개수 ---> dfsAll()에서 dfs()를 수행한 횟수 = 그래프 컴포넌트(component)
-------------------------------------------------------------------------------------------------------

3. 위상 정렬(topological sorting) : 의존성 그래프(dependency graph) ---> DAG의 정점을 배열하는 문제
- dfsAll()을 수행하며 dfs()가 종료할 때마다 현재 정점의 번호 기록.
- 기록된 정점을 뒤집으면 위상 정렬됨.
*귀류법을 통해 증명 가능

-------------------------------------------------------------------------------------------------------
4. 오일러 서킷(한붓 그리기)
:모든 간선을 정확히 한 번씩 지나서 시작점으로 돌아오는 경로

무향 그래프
*오일러 서킷이 존재할 수 없는 경우(시작점 : u, 끝점 : v)
1) 두개 이상의 컴포넌트에 나뉘어 있는 경우
2) - (u != v) : v의 차수(degree)는 홀수
   - (u == v) : v의 차수는 짝수
---> 모든 정점의 차수가 짝수여야 오일러 서킷이 존재 가능하다.
(간선이 모두 컴포넌트 하나에 포함된 무향 그래프는 저점의 차수가 모두 짝수면 항상 오일러 서킷이 존재)

//adj[i][j] = i, j 사이의 간선의 수
vector<vector<int>> adj;
//결과를 뒤집으면 오일러 서킷이 된다
void getEulerCitcuit(int here, vector<int>& circuit){
    for(int there = 0; there < adj.size(); ++there){
        while(adj[here][there] > 0){
            adj[here][there]--;
            adj[there][here]--;
            getEulerCitcuit(there, circuit);
        }
    }
    circuit.push_back(here);
}

---> 오일러 트레일 : 시작점과 끝점이 다른 오일러 서킷
*a-b 오일러 트리
1) a, b 사이에 간선 (b, a) 추가
2) a 오일러 서킷 찾기
3) 오일러 서킷에서 (b, a) 삭제
---> 시작점, 끝점은 차수가 홀수, 나머지는 짝수여야 오일어 트레일 존재 가능능