비트마스트(bitmask)
: 정수의 이진수 표현을 자료 구조로 쓰는 기법

장점
- 더 빠른 수행
- 간결한 코드
- 메모리 절약
- 연관 배열을 배열로 대체 : map<vector<bool>, int> 를 int[]로 변환 가능

-------------------------------------------------------------------------------------------

비트 연산자
AND : a & b
OR : a | b
XOR : a ^ b
NOT : ~a
shift : a << b, a >> b(정수 a를 왼쪽/오른쪽으로 b비트 시프트)
-------------------------------------------------------------------------------------------

비트 연산시 주의점

1. C++에서 비트 연산자는 ==, != 보다 우선순위가 낮다
---> 비트 연산자를 사용할 때는 괄호를 사용하는 습관 필요

2. 64비트 정수 비트마스크로 사용시 오버플로우 조심.
상수 1은 기본적으로 부호가 있는 32비트 데이터로 간주됨. 따라서 활용전에 항상 type 변환을 시켜줘야함

-------------------------------------------------------------------------------------------

비트마스크 사용
: 비트를 통한 집합의 표현
ex) {1, 4, 5, 6, 7, 9} ---> 10 1111 0010 = 754

1. 공집합, 꽉 찬 집합 구하기
공집합 : 0
꽉 찬 집합 : (1 << n) - 1

2. 원소 추가
: 특정 원소의 비트를 키는 것을 의미

집합 |= (1 << p);

3. 특정 원소 상태 확인
집합 & (1 << p);
---> 결과는 0 또는 (1 << p)이다 (0과 1이 아니다)

4. 원소 삭제
집합 &= ~(1 << p);

5. 토글(toggle) : 해당 원소의 상태를 반대로 변경
집합 ^= (1 << p);

-------------------------------------------------------------------------------------------

두 집합 연산
---> 수행 시간이 원소 하나와 같다.

1. 합집합 = (a | b)

2. 교집합 = (a & b)

3. 차집합 = (a & ~b)

4. 토글 = (a ^ b)

-------------------------------------------------------------------------------------------

집합 크기 구하기
: 간단한 방법이 없다. 비트를 순회하면서 켜져있는 비트를 확인해야 한다.

int bitCount(int x){
    if(x == 0) return 0;
    return x % 2 + bitCount(x / 2);
}

***c++ : __builtin_popcount(집합);

-------------------------------------------------------------------------------------------

최소 원소 구하기

1. 최소 원소의 위치 구하기
내장 함수 사용
: c++ = __builtin_ctz(집합);

2. 최소 원소 구하기
= (집합 & -집합)
: 음수 표현을 위해 2의 보수를 사용하는 원리를 적용

3. 최소 우너소 지우기
= (집합) &= (집합 - 1);
: 최하위 비트를 지웠을 때 0이 된다면 그 수는 2의 거듭제곱이다.

4. 모든 부분 집합 순회
for(int subset = 집합; subset; subset = (subset - 1) & 집합){
    //subset은 집합의 부분집합
}

-------------------------------------------------------------------------------------------

활용

1. 지수 시간 동적 계획법

2. 에라토스테네스의 체

3. 제한된 크기의 상태 표현

4. O(1) 우선순위 큐

