검색 트리(search tree) : 자료를 일정한 순서로 저장한 컨테이너

이진 검색 트리(binary search tree)
-대부분 언어의 표준 라이브러리에서 제공
---> 라이브러리에서 제공하지 않는 연산이 필요한 경우 변종인 트립을 구현하여 활용함.

ex) 탐색, 삽입, 삭제: O(log n)
set<T> 정렬된 집합 (중복 불가)
map<K, V> 정렬된 딕셔너리
multiset<T>	중복 허용된 정렬 집합
multimap<K, V> 중복 허용된 딕셔너리

*이진 트리 : 최대 2개의 자식 노드만을 가질 수 있는 트리

정의 : 각 노드의 왼쪽 서브트리에는 해당 원소 보다 작은 원소를 가진 노드들,
       오른쪽 서브트리에는해당 원소 보다 큰 원소를 가진 노드들이 위치하는 이진 트리.
----------------------------------------------------------------------------------------------
속성

- 중위 순회를 하면 크기순으로 정렬된 원소 목록을 얻을 수 있다.

- 자료의 검색 : 이진 탐색과 비슷한 속도로 특정 자료를 찾을 수 있다

***위 특성은 정렬된 배열보다 이점이 없다.

- 조작 
1: 추가
자료의 위치를 찾고 노드만 추가하면 됨 ---> 자료 검색과 비슷한 시간에 해결 가능
(정렬된 배열은 선형적 자료 구조의 제약으로 위치를 찾은 후 그 뒤 모든 원소를 한칸씩 움직여야한다.)

2. 삭제     ***가장 까다로운 연산
삭제는 트리 어디서든 일어 날 수 있기 때문에 어렵다. ---> 루트를 삭제 할 수도 있다

*해결법
'합치기' 연산을 통해 구혈 가능
노드 t를 삭제 ---> t의 두 서브트리를 합친 새로운 트리를 만든다 ---> t를 루트로 하는 서브트리와 바꾼다.

*'합치기'
트리 A, B 합치기(A(최대원소) < B(최대원소) 가정)
---> A의 루트 a가 합친 트리의 루트가 됨. (a의 왼쪽 서브트리 원소는 모두 a 보다 작다, 오른쪽 서브트리 원소는 모두 a 보다 크다)
---> 오른쪽 서브트리와 B를 재귀적으로 합친 뒤 a의 오른쪽 서브트리로 둔다.

----------------------------------------------------------------------------------------------

시간 복잡도---> O(h) //h : 는 이진 검색 트리의 높이

자료 개수 N에 따른 h의 변화
한쪽으로 '기울어졌다(skewed)' 이면 높이가 N-1이 된다. 이러면 이진 검색 트리를 사용할 이유가 없다

최소 높이는 높이 1이 늘어 날때마다 저장 할 수 있는 자료는 2배 늘어나므로 -> lgN 이 된다.

***균형 잡힌 이진 검색 트리(balanced binary search tree)
트리 구조에 추가적인 제약을 정하여 항상 높이가 lgN이 되도록 유지
::레드-블랙 트리(red-black tree) : 가장 대표적인 '균형 잡힌 이진 검색 트리'(대부분 표준 라이브러리는 내부적으로 사용)