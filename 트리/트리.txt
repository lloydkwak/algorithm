선형 구조가 아닌 계층 구조를 가지는 객체들을 표현하기 위한 자료구조
ex) 대진표, 조직도, 상품 등록 기준

*특정 조건을 지키도록 구성된 트리를 활용하면 탐색을 배열이나 리스트 보다 훨씬 효율적으로 할 수 있다.
---------------------------------------------------------------------------------------------

정의 : 자료가 저장된 노드(node)들이 간선(edge)으로 서로 연결된 자료구조

node : 상위 노드를 부모(parent), 하위 노드를 자식(child) 노드라고 부른다.
+ 부모 노드가 같은 노드를 형제(sibling), 부모 노드들을 통틀어 조상(ancestor), 
  자식 노드들을 통틀어 자손(descendant) 노드라고 한다.

*자식은 어려개 있을 수 있지만 부모는 하나만 가진다.
---> 트리에서 다른 모든 노드를 자손으로 갖는 노드는 단 하나다. ===> 뿌리 혹은 루트(root)라고 한다.
+ 자식이 없는 노드 : 리프(leaf)

깊이(depth) : root에서 특정 노드 까지 거쳐야하는 간선의 수를 그 노드의 depth라고 한다.
---> 트리에서 가장 depth가 깊은 노드의 depth를 트리의 높이(height)라고 한다.

서브트리(subtree) : 트리에 속한 어떤 노드 t와 그 자손들로 구성 된 트리를 't를 root로 하는 subtree' 라고 한다.
---> 트리는 루트와 루트 밑에 있는 서브트리로 구성된다
    = 트리는 재귀적 속성을 가지며, 따라서 구현에 재귀 호출을 활용된다.

---------------------------------------------------------------------------------------------

*트리의 가장 일반적인 구현
- 노드를 구조체/객체 표현후 이들은 포인터로 연결.

트리의 노드를 표현한 객체의 구현

struct TreeNode {
    string lable;   //저장할 자료(문자열일 필요 없음)
    TreeNode* parent;   //부모 노드를 가르키는 포인터
    vector<TreeNode*> children; //자식 노드들을 가르키는 포인터
};

---------------------------------------------------------------------------------------------

트리의 순회
: 재귀적 속성을 활용한다
---> 루트를 방문한 뒤 각 서브트리를 재귀적으로 방문하는 함수를 만들어 순회

ex)
//모든 노드를 방문하여 저장 값 출력
void printLabels(TreeNode* root) {
    //루트에 저장된 값 출력
    cout << root->lable <<endl;
    //각 자손들을 루트로 하는 서브트리에 포함된 값들을 재귀적으로 출력
    for(int i = 0; i < root->children.size(); ++i){
        printLabels(root->children[i]);
    }
}

//root를 루트로 하는 트리의 높이 출력
int height(TreeNode* root){
    int ret = 0;
    for(int i = 0; i < root->children.size(); ++i){
        ret = max(ret, 1 + height(root->children[i]));
    }
    return ret;
}

---------------------------------------------------------------------------------------------
