
우선순위 큐
: 큐와 똑같이 순서대로 기다리고 있는 자료들을 저장한다.

차이점 : FIFO가 아니라 우선순위(priority)가 높은 순으로 자료를 꺼낸다.

*균형 잡힌 이진 검색 트리로도 표현 할 수 있지만, 훨씬 간단한 힙(heap)이라는 트리로 구현 가능하다

-----------------------------------------------------------------------------------------------

힙 : 가장 큰 원소를 찾는 데 최적화된 형태의 이진 트리.      //엄밀히 말하면 이진 힙(binary heap)이다.
삽입, 탐색 모두 O(lgN)에 가능.
- 대부분 언어의 표준 라이브러리에서 제공

---> 우선순위와 실제 자료의 쌍이 담긴 힙을 만들고, 대소 관계를 우선순위로 비교하면 된다.

규칙 : 부모 노드가 가진 원소는 항상 자식 노드가 가진 원소 이상이다. (힙의 대소관계 규칙)
***이진 검색 트리와는 다르게 부모 자식 간에만 규칙 성립.
---> 트리의 가장 큰 원소는 항상 트리의 루트가 된다.

힙의 모양 규칙
- 마지막 레벨을 제외한 모든 레벨에 노드는 꽉 차있어야 한다.
- 마지막 레벨에 노드는 항상 왼쪽부터 채워야 한다.
---> 힙의 모양은 트리에 포함된 노드의 개수에 따라 정해진다.

-----------------------------------------------------------------------------------------------

힙의 구현
배열을 통해서 쉽게 구현 가능하다.

-A[i]에 대응되는 노드의 왼쪽 자손은 A[2*i+1]에 대응된다
-A[i]에 대응되는 노드의 오른쪽 자손은 A[2*i+2]에 대응된다
-A[i]에 대응되는 노드의 부모 노드는 A[(i-1)/2]에 대응된다(나눈 결과는 내림 --- > int 나누기)
-----------------------------------------------------------------------------------------------
vector<int> heap;       //정수를 저장하는 힙
-----------------------------------------------------------------------------------------------

*삽입 연산
- 먼저 모양 규칙을 만족하기 위해 배열 마지막에 밀어 넣는다.
- 부모노드와 비교하여 크기가 더 크면 바꾼다.
-----------------------------------------------------------------------------------------------
void push_heap(vector<int>& heap, int newValue){
    heap.push_back(newValue);
    int idx = heap.size() - 1;
    while(idx > 0 && heap[(idx-1)/2] < heap[idx]){
        swap(heap[idx], heap[(idx-1)/2]);
        idx = (idx - 1) / 2;
    }
}
-----------------------------------------------------------------------------------------------

*최대 원소 꺼내기 ---> 삭제 연산
- 삽입 연산과 마찬가지로 모양 규칙을 먼저 만족하게 heap의 끝 노드를 삭제한다
- 끝에 위치해 있던 노드의 원소를 꺼내는 노드의 원소로 넣는다. ---> 루트에 넣는다.
- 자식 노드의 원소와 크기를 비교하고 이동 시킨다
-----------------------------------------------------------------------------------------------
void pop_heap(vector<int>& heap) {
    heap[0] = heap.back();  //원소 바꾸기
    heap.pop_back();    //마지막 노드 삭제
    int idx = 0;
    while(true){
        int left = idx * 2 + 1, right = idx * 2 + 2;
        //리프에 도달한 경우
        if(left >= heap.size()) break;
        //크기에 따라 이동
        int next = idx;
        if(heap[idx] < heap[left]) next = left;
        if(right < heap.size() && heap[next < heap[right]]) next = right;
        if(next == idx) break;
        swap(heap[idx], heap[next]);
        idx = next;
    }
}
-----------------------------------------------------------------------------------------------

*힙 정렬
주어진 배열을 힙으로 만들고 이를 모드 꺼내어 정렬된 배열을 얻는 방식.
이때 꺼낸 최대 원소를 다시 힙 배열의 마지막 자리에 채워 추가 메모리를 아낄 수 있다.
---> 최악의 경우에도 O(NlgN)에 가능하며 추가 메모리를 요구하지 않음.