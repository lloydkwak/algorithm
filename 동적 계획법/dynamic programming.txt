분할정복과 접근 같은 접근방식
단, 문제를 분해하는 방식에서 차이가 발생

***단계
1. 완전 탐색을 통해 문제 해결
2. memorization 적용을 통해 중복 계산 제거

중복 되는 부분 문제(overlapping subprablems)의 결과를 저장하고 재사용하는 방식으로 연산 횟수를 줄이는 방식
===> 사용 공간을 늘려 시간을 줄이는 형태

cache = 부분 문제의 결과를 저장하는 장소
---> cache를 통해 함수의 계산 결과를 재사용하는 기법를 memorization 이라고 한다.
***memorization은 참조적 투명 함수(referential transparent function) 경우에만 사용가능
-> referential transparent function = 입력이 같을 때 결과가 항상 같은 함수, 즉 외부의 다른 변화에 영향을 받지 않는 함수를 뜻함.

memorization 처리
1. 항상 기저 사례를 가장 먼저 처리한다.(입력의 범위를 벗어난 경우 cache에 접근하면 문제 발생)
2. cache에는 함수의 결과가 될 수 없는 값으로 초기화 해두어라. ---> 함수 계산 여부를 확인하기 위함
3. ret을 cache 에대한 참조자로 처리하라. 매번 cache[][]로 쓰는 귀찮음 해소 밑 실수를 줄일 수 있다.
4. memset()을 이용해 cache 초기화, memorization 에서 cache 초기화는 자주 하기 때문에 for문 보다 효율적인 방법을 알아두자.

시간 복잡도 분석
(부분 문제의 수) * (부분 문제를 풀 때 필요한 반복문의 수) ===> 수행시간의 상한을 계산.
ex. 이항 계수 문제의 경우 부분 문제의 수는 n^2, 반복문은 없으므로 최종 시간복잡도는 O(n^2)

----------------------------------------------------------------------------------
[기본 형태]

//dpFunction에서 나올수 없는 결과값으로 초기화
int cache[][];

int dpFunction(...){
    //기저 사례
    if(...) return ;

    //이미 처리한 문제일 경우 바로 반환
    int& ret = cache[][];
    if(ret == (초기화값)) return ret;
    
    //부분 문제에 대한 답 계산
    점화식을 이용한 재귀
    ...
    return ret;
}

int main(){
    memset(cache, (초기화값), sizeof(cache));
}
----------------------------------------------------------------------------------